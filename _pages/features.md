---
ID: 2055
post_title: Symbol server features
author: Eugene Bushtyrev
post_date: 2014-11-07 23:28:37
post_excerpt: ""
layout: page
permalink: https://symbols.pro/features/
published: true
post-option:
  - '{"sidebar":"no-sidebar","left-sidebar":"Footer 1","right-sidebar":"Footer 1","page-style":"normal","show-title":"enable","page-caption":"","show-content":"enable","header-background":""}'
above-sidebar:
  - |
    [{"item-type":"item","item-builder-title":"auto_sym","type":"content","option":{"page-item-id":"","title-type":"none","title":"Automatic symbols discovering","caption":"","content":"<h3 id=|gq2|auto-symbols|gq2|>Automatic symbols loading</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|></p>|g1n|<p style=|gq2|text-align: justify;|gq2|>After completing the server part installation, configure the environment variables on the developer's machine. After this symbol files discovery and loading works without your intervention. Your debuggers and other utilities detect the presence of the symbol server using environment variables. When you debug a process or open dump, symbol loading happens automatically. This process is so simple that after a while you forget that the symbols were any problems. Now, your engineers will not seek appropriate symbols throughout the corporate network or in an archive folder. You can also forget about the possibility of losing symbols. A very common case is when the symbols from the already released products are lost for various reasons. They may be lost as a result of virus activities, failure of the storage subsystem, or be removed by mistake and overwritten by errors of various software. Sometimes symbols are removed inadvertently and by quite legitimate methods - procedures retention. Here, the deletion of symbols can be a result of human error. Without symbols, you can not keep your customers, as well as to process and learn dumps sent from them. If you use a dump delivery mechanism like WER web portal sysdev.microsoft.com, symbols of all the products produced by you shall be promptly available to engineers and their analysis tools.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"auto_source","type":"content","option":{"page-item-id":"","title-type":"none","title":"Automatic source loading","caption":"","content":"<h3 id=|gq2|auto-source|gq2|>Automatic source files loading</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>This feature also allows you to automatically download the source code of your program, along with the symbols. Now, debuggers, and other utilities will be able to download the source code from version control systems automatically, making the debugging process in a real pleasure. There is no need to determine the appropriate revisions in the version control system to download the source code to the computer during debugging session. This loads only necessary source files - for example, when you are debugging a dump, the only files will be downloaded, which take part at the stack contents. This time saving feature is particularly important when you investigate your customer's problem using remote debugging, or want to quickly get information from utilities, which can work with the source code files - such as the Process Monitor.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"ms_debuggers","type":"content","option":{"page-item-id":"","title-type":"none","title":"Microsoft debuggers-ready","caption":"","content":"<h3 id=|gq2|debuggers|gq2|>Microsoft-debuggers compatible</h3>|g1n|<h3 style=|gq2|text-align: justify;|gq2|></h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Server symbols can be easily integrated with debuggers such as: Visual Studio, Windbg, cdb, ntsd and many other third-partied one. Symbols server functionality is exposed to debuggers after setting up several environment variables. To simplify the configuration of workstations, an installation package can be used (available separately), so that you can configure through the Group Policy, SCCM, or by other means of network administration.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"released_protection","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|release-protection|gq2|>Released symbols protection</h3>|g1n|A very common case in companies producing software, when the symbols of the released products disappear as a result of lack of attention to them at the end of the product development cycle. Often companies are not interested in this issue, until the moment comes when it is too late. Symbols are very valuable information and should be treated as. In addition to other features, the symbol server allows you to mark symbols as a 'released' (or non-removable) to prevent accidental removal through the web or command line interface. After that the symbols can be removed only if the explicit removal of the mark.","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"web_panel","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|web-panel|gq2|>Web interface for managing symbols</h3>|g1n|Symbol server provides the ability to manage symbols through a web interface. The set of possible actions can be configured for a specific user and group.","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"we_recursive","type":"content","option":{"page-item-id":"","title-type":"none","title":"We are recursive","caption":"","content":"<h3 id=|gq2|we-recursive|gq2|>We are recursive!</h3>|g1n|To understand recursion, one should understand recursion! Symbols from our server symbols are also stored on the server symbols. We use our own products to develop our products, which helps us keep track of stability and add only those features that are really needed.","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"release_criteria","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|release-criteria|gq2|>Release-ready product criteria</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Sooner or later there comes a time when the software is almost ready for the release. It is very important to have the correct symbols for such a builds. Correct symbols - files that can be accepted by the debugger and other tools without errors. As you know, mistakes happen everywhere and symbols are no exception here. If the symbol server reported an error during symbol loading, the build of a particular product should not leave the organization. It is even pointless to test it, as the absence of valid symbols is dangerous and it is better to rebuild the product from scratch. Only the message about the successful upload of symbols can guarantee the fact that you can load symbols for a particular build of your product to the debugger. This notification may be considered as the first prerequisite of product release acceptance procedure. Symbol loading result can be also viewed using the web interface. Specific build of the product is ready for testing, if it at least has a green check mark in a web panel. The only thing to take care of - mark the appropriate set of symbols as 'released' to ensure the future preservation of the symbols for the entire period of product support.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"compressed_storage","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|compressed-storage|gq2|>Compact symbols storage</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Server symbols keeps your data in compressed form. Symbols are compressed to about 13 times. This means that they will take place at least ten times less on your storage subsystem. As a consequence, the compact storage of symbols leads to more efficient use of disk space. Now, you spend less on the resources needed: your data and it's backups take up less space. Another nice consequence of compact storage is to save bandwidth on your network. Now, debuggers and other tools request the symbols in a compressed form, unpacking them only upon receipt. While less data is transmitted the speed of symbols loading increases. Uploading the same pdb files on symbol server will not occupy any space. This situation can occur if you rebuild only the part of the product, and the rest is taken in already assembled binary form (for example, if several products use shared libraries), or when the build artefacts are copied to multiple folders. It saves a lot of storage space at the stages of product development and during its maintenance. As a matter of fact, symbols of your products is now stored in one place, allowing you to back up all the symbols at once, without wasting time to collect files from multiple network resources.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"single_entry_point","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|single-entry-point|gq2|>Single entry point</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>It's very convenient to have a single entry point for debugger to access all the symbols for your products. This becomes especially important when you have multiple storage locations of your old symbols. For example, you could have some legacy network folders. The symbol server allows you to use symbols from all those locations: just register these folders and use a single entry point! Your engineers use a single http(s) address as a source for the debugger to get symbols from. This feature adds a level of indirection in working with symbols and hides your possible legacy symbol locations. This allows you to add new storage, as well as delete or maintain old ones, opaque to the user. It does not matter how many products you produce and where their symbols were previously stored. Now you just start the build process, and when it completes, you use a single entry point to access symbols. Having completed the environment setup once, you are ready to load symbols automatically via a single entry point as soon as the build process completes.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"easy_integration","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|easy-integration|gq2|>Easy integration with any environment</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Symbol server functionality easily integrates into a variety of environments using a command line utility. Just install it on your build machine, execute it with the right arguments and voila! A portable version is available too, which requires no installation, consisting of a single file. As an example of the integration, you could launch this utility at the end of your build script, irrespective of what kind of build technology is used: it should only allow you to run processes with the right arguments. It is also possible to create a separate task for MSBuild, or start this utility during the post build step in Visual Studio environment. It supports both local and cloud deployment options. The command line utility appears to be the facade to the server symbol functionality. You can add, delete data, mark symbol packages as released (non-removable), index files of symbols to support the functionality to automatically download the source code.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"fast_propagation","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|fast-propagation|gq2|>Fast symbols propagation</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>It is important that the symbols are made available to engineers right in a short time after the product build completes. The actual time depends on your system configuration and the symbols size. Anyway, the symbol server processes data quickly and efficiently, ensuring your engineers have instant access to symbols. Once the build process is completed, related product symbols become available through a single entry point via http(s). Here are some examples from the real world: 50MB of symbols were processed for less then a minute. A few minutes it took to process the gigabyte of symbol files.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"format_support","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|formats-support|gq2|>Various formats support</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Server symbols can store various types of symbolic information, as well as executables themselves. The server provides the ability to save symbols for: Typical applications, services and drivers, i.e. executable files with extensions exe, dll, sys, vxd etc. Mobile Applications Cloud Applications You can also upload the symbols obtained earlier - when you have not yet installed the symbol server. If desired, you may add the version control information to symbol files to support the automatic source download too. You can also upload various executable files with extensions exe, dll, sys etc. Binary files are requested from the symbol server in certain scenarios of kernel and user mode dump debugging. The necessary binary files will be downloaded through the same entry point that is used to deliver symbols. The server processes the symbols both from unmanaged and managed code. If you are using Visual C ++, or C #, or another .NET language - you leverage the same user experience with symbol server</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"debugging_elimination","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3><span style=|gq2|font-size: 1.17em; line-height: 1.5em;|gq2|>Debugging elimination</span></h3>|g1n|Â |g1n|<p style=|gq2|text-align: justify;|gq2|>In certain cases, your engineers will be able to solve the problem without resorting to debug applications. This includes research techniques without debugger - for example using Process Monitor utility. In this case, you simply collect Process Monitor logs while reproducing the issue and save them for later analysis. Select the event you find interesting (for example, always suspicious events with a 'Result' of ACCESS_DENIED), go to the Stacks view and see the symbol loading progress - only the needed symbols are loaded, depending on modules which are present at the stacks. Having symbols downloaded, you'll see both the user and kernel mode stacks of calling thread here. This is possible due to the fact that the Process Monitor integrates with the symbol server by reading configuration from some environment variables. A very useful feature within this window - a 'Show source' button. If you have your environment properly configured, you will see a source code containing the current stack frame, after pressing this button. Observing the source code as well as the result of a particular event, provided by Process Monitor utility, you can often find the cause of the undesired behaviour. Sometimes it comes critical to investigate the customer issue quickly and provide a fix as soon, as possible.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"remote_debug","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|remote-debugging|gq2|>Remote debugging got simple!</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Remote debugging becomes much easier if you use the functionality of the symbol server. Now, using your opportunities, you can automate your routine debugging actions. Symbol server provides maximum comfort when it comes to working with debugging symbols. In fact, remote debugging session can act as just a confirmation. You attach a remote debugger to a process(using Visual Studio, WinDbg etc.), or open a dump file. Everything else will be done by the symbol server itself. As a result, your customers get quick support, your engineers save the time because the necessary symbols and source files are loaded automatically. It is worth noting that the symbols and the source files are available only to your engineers; your customers can not retrieve any of those files at all.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"debugging_modes","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|debugging-modes|gq2|>Different debugging modes support</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Server symbols can be used for both local and remote debugging. User experience does not differ, whether you debug managed, unmanaged, or mixed code. Symbol server helps debug mobile and desktop applications as well as cloud solutions and dumps. It also used for the performance analysis alongside xperf utility, as the latter is highly dependent on the presence of the correct symbols. You take the benefits of symbols loading during kernel debugging too. No matter which mode you use, the symbol server provides quick and easy access to the required information, and helps other tools.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"speed_up_bugfix","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|speed-up-bugfix|gq2|>Speed up the bugfix and the entire development</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>Almost always working with the raw symbols causes a lot of problems. Raw symbols - symbols left on the build server along with other artefacts. Sometimes artefacts left so the symbols disappear. Most often it's just hard to find the proper symbols in the jungle of various builds. If your build symbols are stored in different folders or buried in the complex directory trees, your engineers have headaches to figure out the right way, putting different paths one by one into the debugger to find the right symbols. It takes a tremendous amount of time, which results in wasting the company's money. Symbol server eliminates the need to manually search for symbols, making all the necessary work for you. Developers can now save their time for other tasks like unit tests, because the symbols now are loaded automatically</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"agile_ci_support","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|agile-ready|gq2|>Agile and Continuous Integration support</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>You can reduce the iteration duration when using symbol server using a methodology of iterative development. This is possible because your developers no longer spend time on infrastructure activities when performing everyday tasks. It's more likely iterations duration will remain the same, as many internal project rules could rely on that. Here, you increase the efficiency of the entire team - it can now perform more tasks, or do other work. Continuous Integration (CI) plays an important role in achieving the required level of your product quality and reliability. Using the CI together with symbol server, gives you feedback on the whole development process. Having the correct symbols for your product always available, your specialists are able to solve almost any problem facing them. When the symbol server is a part of the CI, you can see a more complete picture of what is happening, seeing error stacks and source code. In some cases, it is even possible to create a defect in the bug tracker attaching the specific location in source code where the error has occurred! Symbol server is useful at any stage of the software development and maintenance. Some automated tests could be a part of the your CI process that track the crashed and hanged modules, test them on memory leaks and other errors. Using symbol server, these tests can be trained to issue extended information about the errors, so that helps to investigate the root causes of issues. Knowing the place up to the line of code where there was a software crash or a memory leak, it is very easy to take quick steps to resolve the issue.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"fast_symbols_loading","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|fast-symbols-loading|gq2|>Fast symbols loading</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>The server uses nginx - just a coolest web server in the world. It has been used for many years by various companies, such as Amazon. Companies chose this solution because of its stability, performance and robustness. Symbol files become available on the intranet through nginx - you can use the http protocol by default or set up more secure https version. The use of this web server allows you to obtain the maximum performance in getting symbol files. Given that the compressed symbol files take about 13 times less the storage space, nginx performance causes debuggers and other utilities load symbols very quickly</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"wer_helper","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|wer-helper|gq2|>Windows Error Reporting program helper</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>By participating in the WER program, you have the access to the crash dumps of your product, collected from around the world. Sometimes the number of dumps can exceed your expectations - in this case it is important to analyze the majority of them to release an update to your customers. Processing WER dumps can be quite simple, if the symbols are loaded automatically. It can also be automated, allowing downloading symbols and source files to prepare dump analysis for your experts.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"dependencies_free","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|deps-free|gq2|>Dependencies free</h3>|g1n|The symbol server requires just a .NET Framework 4.5 to be installed. This requirement is valid both for the server side, and for the command line utility. There are big chances you already got it carried by Windows Update or shipped with a modern operating system. Symbol server doesn't require sophisticated applications that consume resources, such as SQL Server. It is a mechanism similar to a Swiss watch - takes up little space and just works","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"retention_support","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|retention-support|gq2|>Retention support</h3>|g1n|The symbols from temporary / debug builds of your product should be periodically removed to free up space in the repository. Usually this is done via a certain formal procedure to remove old builds and cleaning a related artifacts such as symbols. Symbol server can be easily integrated in such procedures by launching our command-line utility. The whole process usually lasts a few seconds, after which you receive a completion notification by email.","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"os_support","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|different-os-support|gq2|>Different architectures and operating system support</h3>|g1n|The server supports a variety of operating systems - those on which support .NET Framework 4.5 installation. Client version: Windows Vista, Windows 7, Windows 8, Windows 8.1, Windows 10 and later. Server version: Windows 2008 SP2, Windows 2008 R2, Windows 2012, Windows 2012 R2 and later. It is strongly recommended to use server operating system to install the server part of the product. The symbol server supports both x86 and x64 architectures, taking advantage of a particular system, and providing the best possible performance on it.","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"access_control","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|access-control|gq2|>Access control</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>By default, the symbol server functions with minimal restrictions on the performed actions. It works immediately after installation, without the need for customization. If you have a need to introduce access control, it provides you such the opportunity. The symbol server's administrator can restrict the rights of specific command-line utility instances used to transmit the symbols on the back end. You can tune access control granularly for these instances, as well as globally enable or disable the authentication for add or remove symbols actions.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"http_access","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|https-access|gq2|>Access via HTTP and SMB</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>By default, symbols become available on the Intranet through the protocol http(s), using the modrn proven web server nginx. This is the recommended way for accessing them, because in this case, the server acts as an additional level of abstraction, helping you add various sources of legacy symbols and retrieve symbols using a single entry point. Http(s) access is recommended because of its accessibility too - organizations rarely limit that kind of traffic. Http(s) protocol is most convenient at the moment and therefore the best choice. Access to the symbols through a shared folder (SMB protocol) is also possible. In this case, you are setting up environment so that the symbols are taken from usual Windows shared folder. This method is not recommended, as you lose the advantages of http abstraction level. Also, this may introduce some issues when working with shared folders. It should be noted that the shared folder can not serve a large number of sessions (connections), and it may be unstable in terms of their intranet availability.</p>","margin-bottom":"20px"}},{"item-type":"item","item-builder-title":"Divider","type":"divider","option":{"page-item-id":"","type":"","size":"","margin-bottom":"50px"}},{"item-type":"item","item-builder-title":"own_symbol_server","type":"content","option":{"page-item-id":"","title-type":"none","title":"","caption":"","content":"<h3 id=|gq2|your-own-symbol-server|gq2|>Your own symbol server - privare or public</h3>|g1n|<p style=|gq2|text-align: justify;|gq2|>The leaders of the IT industry are already using symbol server in their work. Microsoft - the founder of the underlying technology of linking executable files and debugging symbols - has a publicly accessible server symbol for developers under the Windows platform. Public server contains, respectively, public symbols - the information necessary to view the stacks of system libraries. Microsoft also has several private symbol servers in its intranet, where the symbols contain some private data required for deep source level debugging. Internal symbol servers are used to avoid the symbols storing issues, as well as provide an access to symbols from different products, their builds and editions. Microsoft can not function properly without these technologies, as otherwise it will be buried under tons of symbols and binary files, which are assembled and tested around the clock. Using the power of the symbol server technology, you are saving a huge amount of time and money, at the same time improving and simplifying your engineers work. This is what Microsoft does every day - using the server symbol helps this company to remain the market leader and technological expert. By installing the symbol server, you will be at the bleeding edge of software development techniques which gives you a chance to apply the modern practices which are already used by the IT industry's professionals.</p>","margin-bottom":"20px"}}]
content-with-sidebar:
  - '[]'
below-sidebar:
  - '[]'
---